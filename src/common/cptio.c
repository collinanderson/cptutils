/*
  cptio.c

  read/write a cpt file
  (c) J.J Green 2004
  $Id: cptio.c,v 1.4 2004/03/18 02:26:38 jjg Exp jjg $
*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <time.h>

#include "cptio.h"
#include "bridge.h"
#include "cptparse.h"
#include "cptscan.h"
#include "version.h"

/* defined in cptparse.c but not exported */

extern int cptparse(void*);

#define LBUF 1024
#define SNM(x) ((x) ? (x) : "<stdin>")

extern int cptdebug;

extern int cpt_read(char* file,cpt_t* cpt,int debug)
{
  FILE    *stream;
  yyscan_t cptscan;

  if (file)
    {
      char *s,*e,*name;

      if ((stream = fopen(file,"r")) == NULL)
	{
	  fprintf(stderr,"error reading %s : %s\n",SNM(file),strerror(errno));
	  return 1;
	}

      /* get the name from the filename */

      name = cpt->name;

      if ((s = strrchr(file,'/')) == NULL) 
	s = file;
      else
	s++;

      strncpy(name,s,CPT_NAME_LEN);

      /* chop off a trailing .cpt */

      if ((e = strrchr(name,'.')) != NULL)
	{   
	  if (strcmp(e,".cpt") == 0) *e = '\0';
	} 
    }
  else
    {
      stream = stdin;
      strncpy(cpt->name,"<stdin>",CPT_NAME_LEN);
    }

  /* 
     assign global cpt* acted upon by the bison parser, I'd like
     this to be an argument for cptparse, but bison only allows 
     one argument & that is used for the scanner
  */

  bridge = cpt;

  /*
    setup scanner
  */

  if (cptlex_init(&cptscan) != 0)
    {
      fprintf(stderr,"problem initailising scanner : %s\n",strerror(errno));
      return 1;
    }
  
  cptset_in(stream,cptscan);
  cptset_debug(debug,cptscan);

  /*
    do the parse
  */

  if (cptparse(cptscan) != 0)
    {
      fprintf(stderr,"failed parse\n");
      return 1;
    }

  cptlex_destroy(cptscan);

  if (!feof(stream))
    {
      if (ferror(stream))
	{
	  fprintf(stderr,"error reading %s\n",SNM(file));
	  return 1;
	}
      else
	{
	  fprintf(stderr,"wierd error reading %s\n",SNM(file));
	}
    }

  if (stream != stdin) 
    fclose(stream);

  return 0;
}

static int fprintf_cpt_aux(FILE*,char,fill_t,model_t);
static int fprintf_cpt_sample(FILE*,cpt_sample_t,model_t);

extern int cpt_write(char* outfile,cpt_t* cpt)
{
    FILE       *stream;
    cpt_seg_t  *seg;
    const char *model;
    time_t      t;

    if (outfile)
    {
	stream = fopen(outfile,"wb");
	if (!stream) return 1;
    }
    else stream = stdout;

    t = time(NULL);

    switch (cpt->model)
      {
      case rgb : model = "RGB"; break;
      case hsv : model = "HSV"; break;
      default :
	fprintf(stderr,"cpt file corrupt : bad model specified\n");
	return 1;
      }

    fprintf(stream,"# %s\n",(outfile ? outfile : "<stdout>"));
    fprintf(stream,"# autogenerated GMT palette \"%s\"\n",(cpt->name ? cpt->name : ""));
    fprintf(stream,"# libgimpcpt version %s, %s",VERSION,ctime(&t));
    fprintf(stream,"# COLOR_MODEL = %s\n",model);

    seg = cpt->segment;

    while (seg)
    {
	fprintf_cpt_sample(stream,seg->lsmp,cpt->model);
	fprintf(stream," ");

	fprintf_cpt_sample(stream,seg->rsmp,cpt->model);
	fprintf(stream,"\n");

	seg = seg->rseg;
    }

    fprintf_cpt_aux(stream,'B',cpt->bg, cpt->model);
    fprintf_cpt_aux(stream,'F',cpt->fg, cpt->model);
    fprintf_cpt_aux(stream,'N',cpt->nan,cpt->model);

    fclose(stream);

    return 0;
}

static int fprintf_cpt_fill(FILE*,fill_t,model_t);

static int fprintf_cpt_sample(FILE* stream,cpt_sample_t smp,model_t model)
{
  int n = 0;

  n += fprintf(stream,"%#7e ",smp.val);
  n += fprintf_cpt_fill(stream,smp.fill,model);

  return n;
}

static int fprintf_cpt_fill(FILE* stream,fill_t fill,model_t model)
{
  int n = 0;

  switch (fill.type)
    {
    case empty:
      n += fprintf(stream,"-");
      break;
    case grey:
      n += fprintf(stream,"%3i",fill.u.grey);
      break;
    case hatch:
      n += fprintf(stream,"%c%i/%i",
		   (fill.u.hatch.sign == 1 ? 'p' : 'P' ), 
		   fill.u.hatch.dpi,
		   fill.u.hatch.n
		   );
      break;
    case file:
      n += fprintf(stream,"%s",fill.u.file);
      break;
    case colour:
      switch (model)
	{
	case rgb:
	  n += fprintf(stream,
		       "%3i %3i %3i",
		       fill.u.colour.rgb.red,
		       fill.u.colour.rgb.green,
		       fill.u.colour.rgb.blue);
	    break;
	case hsv:
	  n += fprintf(stream,
		       "%#7e %7e %7e\n",
		       fill.u.colour.hsv.hue,
		       fill.u.colour.hsv.sat,
		       fill.u.colour.hsv.val);
	  break;
	default:
	  break;
	}
    }
  
  return n;
}

static int fprintf_cpt_aux(FILE* stream,char c,fill_t fill,model_t model)
{
  int n=0;

  n += fprintf(stream,"%c ",c);
  n += fprintf_cpt_fill(stream,fill,model);
  n += fprintf(stream,"\n");

  return n;
}
