/*
  cpt.h

  A struct to hold a GMT cpt file, and some operations 
  on theml

  (c) J.J.Green 2001
  $Id: cpt.c,v 1.4 2001/06/06 23:55:31 jjg Exp $
*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "colour.h"
#include "cpt.h"
#include "version.h"

static int print_cpt_aux(FILE*,char,rgb_t);

extern cpt_t* cpt_new(void)
{
    cpt_t* cpt;

    if ((cpt = malloc(sizeof(cpt_t))) != NULL)
    {
	cpt->segment=NULL;
    }

    return cpt;
}

extern int cpt_prepend(cpt_seg_t* seg,cpt_t* cpt)
{
    seg->lseg = NULL;
    seg->rseg = cpt->segment;

    cpt->segment = seg;

    return 0;
}

extern int cpt_append(cpt_seg_t* seg,cpt_t* cpt)
{
    cpt_seg_t* s;

    s = cpt->segment;

    if (!s) return cpt_prepend(seg,cpt);
 
    while (s->rseg) s = s->rseg;
 
    s->rseg = seg;
    seg->lseg = s;
    seg->rseg = NULL;
 
    return 0;
}

extern int cpt_write(char* outfile,cpt_t* cpt)
{
    FILE       *stream;
    cpt_seg_t  *seg;
    time_t      t;

    if (outfile)
    {
	stream = fopen(outfile,"wb");
	if (!stream) return 1;
    }
    else stream = stdout;

    t = time(NULL);

    fprintf(stream,"# %s\n",outfile);
    fprintf(stream,"# generated by gimpcpt version %s from\n",VERSION);
    fprintf(stream,"# %s \n",cpt->name);
    fprintf(stream,"# %s",ctime(&t));
    fprintf(stream,"# RGB colour model\n");

    seg = cpt->segment;

    while (seg)
    {
	cpt_sample_t l,r;

	l = seg->lsmp;
	r = seg->rsmp;
	    
	fprintf(stream,
		"%#7e %3i %3i %3i %#7e %3i %3i %3i\n",
		l.val,
		l.rgb.red,
		l.rgb.green,
		l.rgb.blue,
		r.val,
		r.rgb.red,
		r.rgb.green,
		r.rgb.blue);
	
	seg = seg->rseg;
    }

    print_cpt_aux(stream,'B',cpt->bg);
    print_cpt_aux(stream,'F',cpt->fg);
    print_cpt_aux(stream,'N',cpt->nan);

    fclose(stream);

    return 0;
}

static int print_cpt_aux(FILE* stream,char c,rgb_t col)
{
    fprintf(stream,"%c %3i %3i %3i\n",
	    c, col.red, col.green, col.blue);

    return 1;
}

extern void cpt_destroy(cpt_t* cpt)
{
    cpt_seg_t *seg, *next;

    if (!cpt) return;
    
    if ((seg = cpt->segment) == NULL) return;

    while (seg) 
    {
	next = seg->rseg;
	cpt_seg_destroy(seg);
	seg = next;
    }
	    
    if (cpt->name) free(cpt->name);

    free(cpt);

    return;
}

extern cpt_seg_t* cpt_seg_new(void)
{
    cpt_seg_t *seg;

    if ((seg = malloc(sizeof(cpt_seg_t))) == NULL) 
	return NULL;

    seg->lseg = NULL;
    seg->rseg = NULL;

    return seg;
}

extern void cpt_seg_destroy(cpt_seg_t* seg)
{
    free(seg);
}



